---
layout: post
title:  "[책] 코딩을 지탱하는 기술"
date:   2019-03-15
tags: [book]
---

  굉장히 넉넉한 마음가짐으로 또 이 책을 집어들었다. 꽤 많이 읽었던 것 같은데 이상하게 머리에 크게 남지 않는 듯한 느낌이 들었지만, 그냥 단순히 내 착각일 거라고 애써 자위해본다. 얇기 때문에 굉장히 만만하게 보인다는 사실이 크게 작용한 것일테지. 오.. 아쉽게도 착각이 아니었다는 것만 빼면 이번에도 재미있었다.

책은 프로그래밍 언어들을 해체하여 그 각각의 요소들에 대해 파고들어가는 방향으로 가닥을 잡은 모양이다. 파고 들어간다는 게 말로는 간단하지만, 실제로는 엄청난 분량의 사전 조사를 하고 선별작업을 해야 하는 등, 굉장히 큰 작업일 것이다. 아마 언어에 대한 크나큰 관심과 애정이 없다면 이렇게까지 조사를 하고 책을 만들진 못할 것이다.

언어의 원리와 역사, 같은 건 사실 인간이 노력하지 않으면 보수적으로 행동하게 된다는 사실에 입각해서 생각해 보면 누군가에겐 정말 하찮은 것일 수도 있을 요소이다. 절차적 프로그래밍에서 객체지향 프로그래밍으로 넘어오는 과도기적 이야기만 해도 객체지향에 너무나 익숙해진 우리들이 생각하기엔 절차적 프로그래밍에서 넘어오길 겁내거나 넘어오는 것을 거부하거나 되려 역정을 내거나 했다는 사실들이 명백히 존재했었지 않나. 언어의 원리가 한번 마음 속에 자리잡으면 다른 것을 틀린 것으로 규정하고 배척하고 무시하고 일종의 신앙으로까지 발전하니, 그 쯤 되면 원리 같은 건, 다양성 같은 건 안중에도 없어진다. 그런 무형의 반발들에도 해체, 분석하여 글타래로 풀어놓다니 존경심이 절로 생긴다. 책에서는 말한다. ‘비교를 통한 배움’과 ‘역사를 통한 배움’을 통해 효율적으로 언어를 배울 수 있다고.

저자의 언어 해체는 숨쉬듯 당연하게 사용했던 도구들을 하나 하나 꺼내 광 내어 원래는 이렇게 생겼던 거야. 하고 보여주는 느낌이다. 연산자 구문 트리를 통해 스택 머신의 발견을 이끌어 내는 건 학부에서 들었던 수업을 떠올리게 하고 어셈블리어의 문법을 그대로 따른 goto문의 강력함이 독이 되어서 if-else, while, for문으로 래핑하게 되었다는 역사, 그리고 그를 클래스 상속의 세 가지 측면에 빗대어 상속보다는 위임(조합을 의미한다.)을 사용하라는 결론까지 내는 것에서는 카타르시스가 느껴질 정도다.

함수와 콜스택과 재귀 호출도 기본중의 기본이니 당연스럽게 들어가 있고, C 스타일의 리턴값은 오류값(int main()처럼. 그런 연유로 리턴값 대신 매개변수로 레퍼런스를 넘겨 받아 수정하는 스타일이 정형화 되어 있다고 알고 있다.)이었으며 그에 불편함을 느껴 예외 처리 구분이 발전했음도 역사를 짚어가며 설명해준다.

함수의 스코프 관련해서는 동적 스코프에서 정적 스코프로 변화되는 과정을 설명해주며 여러가지 생각의 여지를 준다. 너무 당연하게 사용하던 도구가 눈 앞에서 너무 번쩍거리는 느낌. 생각해보면 상속, 다중 상속, 죽음의 다이아몬드 등도 스코프에 입각해서 생각해 볼 수 도 있을 것 같다.

형의 탄생과 부동 소수점, 컨테이너와 빅오, 문자 집합의 탄생과 유니코드의 역사, 쓰레드 프로그래밍과 메모리 공유와 액터 모델(메시지 방식), 값이 변경 불가능하면 쓰레드 세이프함도 한번 훑어주고. 마지막으로는 클래스와 객체 지향, 객체 지향이란 어떤 것인가에 대한 꽤 철학적인(객체 지향이라는 것 자체가 사실 사상에 지극히 가까우니.) 이야기도 나눈다. 당연히 클래스가 있어야 객체 지향이지 않느냐는 생각을 반전시키며 꽤 재미를 준다.

이래저래 안 짚은 것 없이 훑기 때문에 가벼운 마음으로 보다가 가볍지 않은 마음으로 책을 덮게 되었다. 역사를 짚어보는 것에 큰 의의가 있는 책이라고 평가하고 싶은데, 옛날엔 바로 그래서 그렇게까지 좋아하진 않았던 것 같았던 기분이 든다. 역사는 늘 되풀이되기에 늘 복기하고 실패에서 배움을 얻어야 한다는 걸 마음이 아니라 머리로 알고 있었던 어린 나이였다.

재미있었다.