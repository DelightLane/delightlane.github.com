---
layout: post
title:  "[More Effective C++] 항목 18 ~ 19"
date:   2016-11-04
tags: [work, cpp]
---

## 항목 18 : 예상되는 계산 결과를 미리 준비하면 처리 비용을 깎을 수 있다. 
- 현재 요구된 것 외에 더 많은 작업을 미리 해 두어 소프트웨어 성능을 향상시켜라 

- 값을 반환하는 함수들을 구현하는 방법 
	>1. 호출 시 모든 데이터를 점검해서 원하는 값을 반환하게 한다. 
	>2. 지연 평가 방법. 그냥 내부 자료구조를 반환하게 해서 그 함수의 반환값이 실제로 사용될 때 거기서 원하는 값을 찾도록 하는 방법
	>3. 과도 선행 방법(함수가 자주 호출되는 환경에서는 비용 절감의 효과가 있다.) 값을 미리 구해 두었다가 함수 호출 시 그 값 호출 

- 구현 방법 
	>1. 이미 계산이 끝났고 또 다시 사용될 것 같은 값을 캐싱한다.(동적 프로그래밍) 
	>2. 미리 가져오기 -> 디스크컨트롤러는 디스크에서 데이터를 읽을 때 적은 양만 요구했어도 블록 하나, 섹터 하나를 왕창 읽는다.(조금씩 여러번보다 한번에 많이 읽는 게 빠르다) 
		>>+ 참조 위치의 근접성(인접한 데이터들이 연달아 읽히는 경우가 많다.) 
- ex) 벡터는 크기가 동적으로 증가할 시 2배수로 데이터 공간을 할당한다.(operator new의 호출 비용이 비싸기 때문이다) 
- 메모리를 많이 쓰면 속도가 빨라진다.(공간과 시간은 함께 절약하기 힘들다.) 

## 항목 19 : 임시 객체의 원류를 정확히 이해하자. 
- C++에서의 진짜 임시 객체는 힙 이외의 공간에 생성되는 '이름 없는' 객체이다.
- 이름 없는 객체가 만들어지는 상황 
	>1. 함수 호출을 성사시키기 위해 암시적 타입 변환이 적용될 때 
	>2. 함수가 객체를 값으로 반환할 때 
- 임시 객체 생성 / 소멸 비용이 전체 성능에 미치는 영향이 꽤 된다. 
- ex) 함수 호출 성사를 위해 생기는 경우 
```cpp
size_t countChar(const string& str, char ch); 
char buffer[MAX_STRING_LEN]; 
countChar(buffer, c);
```
- char 타입 배열을 string 타입 임시 객체로 만들어준다. 
- 이 임시객체는 countChar가 복귀할 때 자동으로 소멸한다. 
- 해결법
	>1. 코드를 다시 설계하여 변환을 제거한다(5) 
	>2. 타입 변환이 불필요하도록 소프트웨어를 수정한다(21) 
- 암시적 타입 변환은 객체가 값 혹은 상수객체 참조자 타입 매개변수로 객체가 전달될 때 일어난다. 
	>+ 즉 비상수 객체 참조자 타입 매개변수 전달시에는 암시적 타입 변환이 일어나지 않는다. 
	>+ 함수 내에서 수정되는 게 상수객체가 아닌 만들어진 임시객체이기 때문. 
- ex) 객체를 (값으로) 반환할 때 
```cpp
const Number operator+(const Number& lhs, const Number& rhs); 
```
	>+ 호출할 때마다 임시객체가 만들어졌다가 없어지는 일을 반복한다. 
	>+ 반환값 최적화(20) 