---
layout: post
title:  "[Effective C++] 항목 44"
date:   2016-09-13
tags: [work, cpp]
---

## 항목 44 : 매개변수에 독립적인 코드는 템플릿으로부터 분리시키자 
- 코드 비대화 : 거의 똑같은 내용의 코드와 데이터가 중복되어 이진파일로 구워질 여지가 있다. 
- 공통성 및 가변성 분석 : 공통 부분을 별도의 클래스로 옮긴 후 클래스 상속 혹은 객체 합성으로 원래의 클래스들이 공통부분을 공유하도록 함 

- 템플릿이 아닌 코드 = 코드 중복이 명시적(눈으로 찾을 수 있다) 
- 템플릿 = 코드 중복이 암시적 

- 공통적으로 사용하는 부분은 데이터까지 모두 부모 클래스로 넘긴다. 생성자의 인자 등으로 자식 클래스의 템플릿 매개변수를 받는다. 
	>+ 크기별 고정 버전(분리 전)이 컴파일 시점에 확정되는 상수 등이 생기기 때문에 상수 전파 등의 최적화가 먹혀 들어가기 좋다. 
	>+ 독립형 버전(분리 후)는 얻을 수 없다. 
	>+ 그러나 분리하면 
		>>1. 실행코드의 크기가 작아진다. 
		>>2. 프로그램의 작업세트(한 프로세스가 자주 참조하는 페이지의 집합) 크기가 줄어들면서 명령어 캐시 내의 참조지역성(프로세스의 메모리 참조가 실행 중 균일하게 흩어져 있지 않으며 특정 지점 및 특정 부분에 집중된다는 경험적 / 실험적 특성)도 향상된다. -> 실행속도 향상 
- 정확한 판단 필요 시 둘 다 적용 후 결과 관찰이 필요하다.

- 타입 템플릿 매개변수 코드 비대화 : 템플릿 매개변수를 함수 매개변수, 클래스 데이터 멤버로 대체해서 비대화를 종종 없앨 수 있다. 
- ex) 
```cpp
template<typename T> 
class Temp {.... } 
```
	>+ Temp<int>와 Temp<long>의 결과 코드가 거의 같으므로 코드중복이 일어난다. 

- 비타입 템플릿 매개변수 코드 비대화 : 동일한 이진 표현 구조를 가지고 인스턴스화 되는 타입들이 한 가지 함수 구현을 공유하게 만듦으로써 비대화를 감소시킬 수 있다. 
- ex) 
```cpp
template<typename T, std::size_t n> 
class Temp { .... } 
```
	>+ Temp<int, 3>과 Temp<int, 4>의 비타입 템플릿 매개변수를 사용하는 코드의 중복이 생긴다. 