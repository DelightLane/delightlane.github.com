---
layout: post
title:  "[Effective C++] 항목 52 ~ 55"
date:   2016-10-11
tags: [work, cpp]
---

## 항목 52 : 위치 지정 new를 작성한다면 위치 지정 delete도 같이 준비하자.
- ex)
```cpp
Widget *pw = new Widget; 
```
	>+ 함수 두 개(operator new 호출 - Widget 기본 생성자 호출) 호출(10, 17) 
	>+ 첫째 함수 통과 후 둘째 함수에서 예외 발생 : C++ 런타임 시스템이 메모리 할당을 안전히 되돌린다. (operator new 함수와 짝이 되는 버전의 delete 함수를 호출) 
    >+ 런타임 시스템이 어떤 operator delete 함수를 호출할 지 알고 있어야 한다. 

- 위치 지정(placement) new : 매개변수를 추가로 받는 operator new 
	>+ 메모리 위치를 나타내는 포인터를 매개변수로 받는 operator new(원조)
- 위치 지정(placement) delete : 매개변수를 추가로 받는 operator delete 
- 만일 짝이 되는 operator delete가 없으면 어떤 operator delete도 호출하지 않는다!
- 위치 지정 delete가 호출되는 경우 : 위치지정 new 호출에 묻어서 함께 호출될 때
- 포인터에 delete를 적용했을 때는 절대로 위치 지정 delete를 호출하지 않는다.
- 어떤 위치 지정 new와 조금이라도 연관된 모든 메모리 누출을 사전에 봉쇄하려면 표준 형태 delete를 기본으로 마련하고 그와 함께 짝이 되는 위치 지정 delete도 빼먹지 말아야 한다. 
- 바깥 쪽 유효범위의 어떤 함수와 클래스 멤버 함수의 이름이 같으면 가려진다.(이름만 같아도 가려진다.)(33) 
- 쉬운 방법 : 기본 클래스(new 및 delete의 기본 형태를 가진)를 만든다. 

## 항목 53 : 컴파일러 경고를 지나치지 말자 
- 컴파일러 경고에 너무 기대지 말자. 컴파일러마다 경고를 내는 부분이 천차만별이다. 

## 항목 54 : TR1을 포함한 표준 라이브러리 구성요소와 편안한 친구가 되자 
- C++98 명시 표준 C++ 라이브러리 주 구성요소 
	>1. 표준 템플릿 라이브러리(STL) : 컨테이너, 반복자, 알고리즘, 함수 객체 등 
	>2. iostream : 사용자 정의 버퍼링, 국제화 기능 가능한 입출력, 사전 정의 객체 
	>3. 국제화 지원 : 여러 로케일 활성화 기능, wchar_t 등 타입(대개 16비트 문자) 및 wstring(wchar_t 타입으로 정의한 string)을 쓰면 유니코드 사용 가능 
	>4. 수치 처리 지원 : 복소수를 나타내는 템플릿(complex) 및 수치 배열 템플릿(valarray) 
	>5. 에외 클래스 계통 : exception 및 파생 클래스 
	>6. C89의 표준 라이브러리 : 1989년 버전 C의 표준 라이브러리 

- TR1 구성요소(지금은 많은 기능들이 표준 라이브러리로 승격) 
	>1. 스마트 포인터 
	>2. function : 시그니처가 비슷하면 호출이 가능한 일반화 콜백 함수를 만들자 
	>3. bind :상수 / 비상수 멤버 함수에 상관 없이 동작 
	>4. 해시 테이블 
	>5. 정규 표현식 
	>6. 튜플(tuple) : 종래 pair 템플릿의 신세대 버전 
	>7. array 
	>8. mem_fn : 멤버함수 포인터를 적용시키는 용도 
	>9. reference_wrapper : 기존 참조자를 객체처럼 사용 
	>10. 난수 발생 
	>11. 특수 용도의 수학 함수 
	>12. C99 호환성 확장 기능 
	>13. 타입 특성 정보(47, 39, 50) 
	>14. result_of : 어떤 함수 호출의 반환 타입 추론 템플릿 

## 항목 55 : Boo자유친! 부스트를 늘 여러분 가까이에. 